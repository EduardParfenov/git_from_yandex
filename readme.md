# Yandex  Практикум

## Курс по основам GIT

##### Данный проект создан в качестве подсобного учебного материала по изучению основ работы с GIT. Проект является исключительно учебным и выполнен в форме конспекта. В проекте отражены основыые тезисы и вехи пройденного материала.

##### Проект создан в личных целях, для использования его в дальнейшем обучении программированию.

## Работа с командной строкой

---
1. Основные команды терминала:

* *pwd* - показать рабочую папку;
* *cd* - смена директории;
* *cd~* - перейти в домашнюю директорию;
* *cd..* - вернуться на уровень выше;
* *ls -a* - вывести содержимое директории, включая скрытые файлы;
* *ls ~* - вывести содержимое домашней директории;
* *ls ..* - вывести содержимое родительской директории.

2. Работа с директориями и файлами:

* *touch* - создать файл (необходимо указывать расширение);
* *mkdir* - создать директорию;
* *mkdir -p* - создать структуру директорий;
* *mkdir ~* - создать директорию в домашней директории;
* *mkdir ..* - создать директорию в родительской директории;
* *cp* - копирование файлов (cp что копируем куда);
* *mv* - перемещение файлов (mv что переносим куда);
* *cat* - прочитать файл в терминале (работает только для txt);
* *rm* - удалить файл;
* *rmdir* - удалить директорию;
* *rm -r* - удалить директорию со всем ее содержимым.

3. Полезные команды:

* *&&* - выполнить несколько команд (используется как разделитель команд);
* */* - переместиться в корневую директорию;
* *~* - переместиться в домашнюю директорию.

## Работа с локальным репозиторием GIT

---
1. Создание репозитория.

- Что бы создать git-репозиторий, переходим в нужную папку-проект и вводим:  
*git init*  
- Что бы "разгитить" папку в которой git-репозиторий больше не нужен вводим:  
*rm -rf .git*  
- Проверить состояние репозитория:  
*git status*

2. Добавить файлы в репозиторий.

- Подготовить к сохранению все файлы репозитория (добавить файлы):  
*git add -all*  
- Добавить файлы в репозиторий по одному:  
*git add todo.txt*  
*git add readme.txt*  
- Добавить в репозиторий всю текущую папку:  
*git add .*

3. Выполняем коммиты.

- Выполнить коммит:  
*git commit -m "в кавычках указываем комментарий"  
- Просмотреть историю коммитов:  
*git log*  

## Работа с удаленным репозиторием GIT

---
1. Связать локальный с удаленным репозиторием (привязать удаленный репозиторий к локальному):  
*git remote add origin "в кавычках указываем SSH-ключ"*  
2. Посмотреть (проверить), что репозитории связаны:  
*git remote -v*  
*(флаг *-v*  это короткая форма записи от --verbos (подробный))*
3. Отправить изменения в удаленный репозиторий:  
*git push -u origin master*  
(где *master* название основной ветки, так же возможно использовать *main*. Флаг *-u* это связка веток удаленного и локального репозитория. При последующих *пушах* фалаг *-u* можно опускать.)

## Файл *README.md*

---

#### Файл *README.md* служит для описания созданного проекта, который был запушен в удаленный *GIT-репозиторий*. Данный файл создается для сторонних участников проекта или сторонних разработчиков, что бы дать описание проекту. Что необходимо описать:

1. Название проекта и его кроткое описание, кем создан, для чего, какие решает задачи и проблемы;
2. Технологии которые применяются в проекте. В чем его отличие от аналогичных проектов.
3. Документация проекта - подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если таковые есть.

#### Для оформления файла *README.md* используется специальный язык разметки - *Markdown*

---

1. Заголовки разных уровней создаются символом - *# - решетка*:

```text
# - H1 - заголовок первого уровня,
```

```text
## - H2 - заголовок второго уровня,
```

```text
### - H3 - заголовок третьего уровня,
```

```text
#### - H4 - заголовок четвертого уровня,
```

```text
##### - H5 - заголовок пятого уровня,
```

```text
###### - H6 - заголовок шестого уровня.
```

2. Чтобы создать черту под заголовком или абзацем используют три тире

```text
---
```

3. Чтобы сделать разрыв строки, нужно поставить два пробела в конце строки.

4. Чтобы начть новый параграф нужно нажать Enter два раза.

5. Выделение текста:

- Чтобы выделить текст курсивом необходимо текст заключить в символы "звездочка" в начале и в конце текста:

```text
*текст*
```

либо заключить текст в символах "нижнее подчеркивание":

```text
_текст_
```

- Чтобы выделить текст полужирным шрифтом необходимо его заключить в двойные "Звездочки" либо в двойные "нижние подчеркивания":

```text
**текст**
```

либо

```text
__текст__
```

- Зачеркнутый текст заключают в двойных знаках тильда (~)

```text
~~текст~~
```

#### Оформление списков

---

1. Нумерованные списки. Данные списки формляются написанием номера по порядку с точкой после цифры:

```bash
1.
```

```bash
2.
```

и т.д.  
2. Не нумерованные списки оформляются с помощью символа "звездочка" в начале или с помощью символа "тире (минус)":

```bash
* какой-то текст
```

или

```bash
- какой-то текст
```

#### Оформление ссылок

---

Для оформления текста как ссылки, сам текст должен быть указан в квадратных скобках, а затем, без пробела, в круглых скобках указывается ссылка на рессурс. Тайтл (всплывающая подсказка) сслыки указывается в кавычках, сразу после ссылки на рессурс.

```bash
[яндекс](https://www.yandex.ru "Я яндекс")
```

#### Оформление кода

---
Для оформления кода используются специальные символы - граверсы, записанные три раза в начале и три раза в конце нужного кода.

```text
(```)
```

Причем три граверса, указываемых в конце - записываются на новой строке.

```text
```bash
ls -la```
```

```html
```html
<h1> А я просто текст  </h1>```
```  

## Хеш - идентификатор коммита

---
Хеш можно посмотреть при выводе истории коммитов командой *git log*.  

Хеширование (от англ. *рубить*, *крошить*) это способ преобразовать набор данных и получить их *отпечаток*.  
Информация о коммите - это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка не предыдуший, или **родительский** коммит. 

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (Secure Hash Algorithm - *безопасный алгоритм хеширования* и) получается для каждого коммита свой уникальный **хеш** - результа хеширования.  

Обычно Хеш - это коросткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0-9 и латинских букв A-F (неважно заглавных или строчных). Она обладает следующими важными свойствами:

* если хеш получить дважды дло одного и того же набора входних данных, то результат будет гарантированно одинаковый;  
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причем сильно).  

Git хранит таблицу соответствий *хеш -> информация о коммите*. Если знать хеш, можно узнать все остальное: автора и дату коммита и содержимое закомиченных файлов.  Хеш - основной идентификатор коммита.  

Хеши можно передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести действие.  

Все хеши и таблицу *хеш -> информация о коммите* Git сохраняет в служебные файлы. Они находятся в папке *.git* в репозитории проекта.  

## Исследуем лог. Элементы написания коммита

---
После вызова *git log* появляется список коммитов.  

```bash
$ git log
commit e007f5035f113f9abca78fe2149c593959da5eb7 (HEAD -> master) --- 1
Autor: John Doe <johndoe@example.com> --- 2
Date: Tue Mar 28 00:26:53 2023 +0333 --- 3

  Добавить амбиций в список дел --- 4
```

Где:
1 - хеш коммита
2 - имя автора и его эл.почта
3 - дата и время создания коммита
4 - сообщение коммита

### Получить сокращенный лог

Получить согращенный лог можно командой *git log --oneline*.  
Команда *git log --oneline* выводит так же согращенных хеш, данная команда автоматически подбирает такую длину хешей, что бы они были уникальными в пределах репозитория.

Если выход из просмотра логов не произошел автоматически, жми клавишу __Q__

## HAED - всему голова

---

При вызове команды *git log* можно замеить надпись *HEAD -> master* после хеша одного из коммитов.

## Файл HEAD

Файл HEAD (англ. головной) - служебный файл папки *.git*. Он указывает на коммит, который сделан последним (то есть на самый новый).

Открыть файл HEAD можно в терминале:

```bash
$ cd .git/ # переходим в папку git
$ ls # смотрим, какие файлв в данной папке
$ cat HAED # смотрим содержимое файла HAED
```

Внутри HEAD  - ссылка на служебный файл *refs/heads/master*. В данном файле можно увидеть хеш последнего коммита.

```bash
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты
```

Когда делается коммит, GIT обновляет файл *refs/heads/master* - записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется.

Если нужно передать последний коммит в качестве параметра в *git*, то вместо его хеша можно прото написать слово *HEAD*.

## Статусы файлов в GIT

---

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.

* *untracked*. Новые файлы в Git-репозитории помечаются как *untracked*, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

* *staged*. После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
*Staging area* также называют *index* (англ. «каталог») или *cache* (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.

* *tracked*. Состояние tracked — это противоположность untracked. В него попадают файлы, которые уже были зафиксированы с помощью *git commit*, а также файлы, которые были добавлены в staging area командой *git add*. То есть все файлы, в которых Git так или иначе отслеживает изменения.

* *modified*. Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

## Про staged и modified

Команда *git add* добавляет в *staging* area только текущее содержимое файла. Если вы, например, сделаете *git add file.txt*, а затем измените *file.txt*, то новое содержимое файла не будет находиться в *staging*.
Git сообщит об этом с помощью статуса *modified*: файл изменён относительно той версии, которая уже в *staging*. Чтобы добавить в *staging* последнюю версию, нужно выполнить *git add file.txt* ещё раз.

## Типичный жизненный цикл файла в Git

```mermaid
<<<<<<< HEAD
graph LR;
=======
graf LR;
>>>>>>> b8dcaad847ba6d7ecb30ca292a6c6b4bb6d467c3
untracked -- "git add" --> staged;
modifield -- "git add" --> staged + tracked;
staged + tracked -- "изменения" --> modifield;
staged + tracked -- "git commit" --> tracked;
tracked -- "изменения" --> modified
```

1. Файл только что создали. Git про него ещё ничего не знает. Состояние: untracked.
2. Файл добавили в staging area с помощью *git add*. Состояние: staged (+ tracked).

* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).
Обратите внимание: staged и modified у одного файла, но у разных его версий.
* Ещё раз выполнили *git add*. Состояние: staged (+ tracked).

3. Сделали коммит с помощью *git commit*. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью *git add*. Состояния: staged (+ tracked).
6. Сделали коммит. Состояния: tracked.
7. Повторили пункты 4−7 много-много раз.

Большинство файлов в проектах «шагает» по следующему циклу: «изменён» -> «добавлен в список на коммит» -> «закоммичен» -> «изменён» -> и так далее.

## Как читать git status

---
Проверять статусы файлов нужно командой *git status*.

## Какие состояния показывает git status

Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды *git status*.

В итоге git status показывает только следующие состояния файлов:
* staged (Changes to be committed в выводе git status);
* modified (Changes not staged for commit);
* untracked (Untracked files).

Подготавливаем репозиторий
Чтобы попрактиковаться, инициализируйте новый репозиторий ~/dev/git-status-lesson. Создайте в нём файл README.md и закоммитьте его.

```bash
$ cd ~/dev
$ mkdir git-status-lesson
$ cd git-status-lesson
$ git init
# тут Git выведет что-нибудь, но мы это пропустим
$ touch README.md
$ git add README.md
$ git commit -m 'Добавить README'
~~~~ # по традиции первым создадим и закоммитим файл README.md
```

Дальше вы будете добавлять в репозиторий файлы и смотреть на их статусы.

## Типичные варианты вывода git status

Рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

1. Нет ни staged-, ни modified-, ни untracked-файлов.
Если ничего не менять в git-status-lesson после первого коммита, то в нём не должно быть ни изменённых файлов (modified), ни новых (untracked), ни добавленных в список на коммит (staged). Вызовите команду *git status*. Её вывод будет примерно таким.

```bash
$ git status
On branch master
nothing to commit, working tree clean 
```

Это означает, что в репозитории нет новых или изменённых файлов. Последняя строка nothing to commit, working tree clean буквально переводится как «нечего коммитить, рабочая директория чиста».
Первая строка On branch master сообщает, что текущая ветка — master.

2. Найдены неотслеживаемые файлы.
Создайте в папке ~/dev/git-status-lesson файл fileA.txt. Теперь в репозитории есть новый файл в состоянии untracked. Снова вызовите команду *git status*. Результат будет таким.

```bash
$ touch fileA.txt
$ git status
On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Файл fileA.txt отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через *git add*.

Обратите внимание: в самом выводе *git status* есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: Use git add <file> to include in what will be committed (англ. «используйте git add <file>, чтобы добавить в список на коммит»).

Добавьте fileA.txt в staging area с помощью *git add* и снова запросите *git status*.

```bash
$ git add fileA.txt 
$ git status
On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt
```

В этот раз *git status* подсказывает, что существует команда *git restore*. Мы познакомим вас с ней в одном из будущих уроков.

Теперь fileA.txt находится в секции Changes to be committed (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

```bash
$ git commit -m 'Добавить файл fileA.txt'
# тут будет вывод комманды commit, он нас не интересует
$ git status
On branch master
nothing to commit, working tree clean
```

Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».

3. Найдены изменения, которые не войдут в коммит
Теперь откройте файл fileA.txt и добавьте в него несколько слов — например, Это файл A!. Сохраните fileA.txt и вызовите команду *git status*. Её результат будет такой.

```bash
# внесли в fileA.txt правки
# запросили статус
$ git status 
On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt
```

Файл fileA.txt был изменён, но ещё не добавлен в staging area после этого. Так он оказался в секции Changes not staged for commit (англ. «изменения, которые не подготовлены к коммиту»). Эта секция соответствует статусу modified.
Подготовьте правки к коммиту с помощью git add.

```bash
$ git add fileA.txt
$ git status
On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt
```

Теперь в коммит попадёт уже новая версия файла fileA.txt.

Обратите внимание: хотя вывод команды git status очень похож на тот, который был после первого добавления файла fileA.txt, они всё же отличаются.
Когда совсем новый файл попадает в staging area, перед его названием указывается new file. Вот так: new file: fileA.txt.
Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения git add он будет записан уже так: modified: fileA.txt.

4. Файл добавлен в staging area, но после этого изменён
Вы добавили файл в staging area, но перед самым коммитом вспомнили важную мелочь. Например, вместо одного восклицательного знака в конце строки Это файл A! нужно поставить три.
Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать git status. Он покажет следующее.

```bash
# изменили fileA.txt
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt
```

Файл попал и в staged (Changes to be committed), и в modified (Changes not staged for commit). В staging area находится версия файла с одним восклицательным знаком, а в Changes not staged for commit — уже изменённая версия, с тремя.
Чтобы закоммитить самую свежую версию файла, нужно снова выполнить *git add* перед коммитом.

## Оформление сообщений к коммитам

---

То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями.
Например, в выводе команды *git log --oneline* умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

## Зачем вообще писать сообщения

У каждого коммита в Git есть сообщение — то, что передаётся после параметра -m. Например: git commit -m "Добавить урок про оформление сообщений коммитов".
Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

* относительно коротким, чтобы его было легко прочитать;
* информативным.

Вот пример полезного сообщения в репозитории новостного сайта: "Исправление опечатки в заголовке главной страницы на хорватском".

Пример плохого сообщения для того же коммита: "Исправлена опечатка".

## Стили оформления

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: "Исправить сообщение об ошибке E123", кто-то — глаголы в прошедшем времени: "Исправил…", кто-то — существительные: "Исправление…".

Чтобы упростить работу, команды и часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.
Например, правила могут быть такие:

* длина сообщения от 30 до 72 символов;
* первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);
* и так далее.

Есть много подходов к оформлению сообщений коммитов, но мы расскажем о нескольких популярных. Их используют как отдельные команды, так и целые проекты.

### Корпоративный

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это это $239$-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

```bash
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"
```

### Conventional Commits

Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:
* feat (англ. «навык») — для новой функциональности;
* fix (от англ. «исправить», «устранить») — для исправленных ошибок.
Более подробный список можно увидеть на [сайте с описанием этого стиля](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)
Например, сообщение может быть таким:

```bash
$ git commit -m "Исправить #334, добавить график температуры"
```

В таком случае GitHub свяжет коммит и задачу.

Инфинитив и императив
Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: "Добавить тесты для PipkaService", "Исправить ошибку #123" и так далее.
Для сообщений на английском рекомендуется использовать повелительное наклонение (англ. imperative). Например: "Use library mega_lib_300", "Fix exit button" и так далее.
Эти рекомендации сложились исторически, и им следуют многие проекты.







---
[Ссылка на проект](https://github.com/EduardParfenov/git_from_yandex/tree/master "Проект git from yandex")